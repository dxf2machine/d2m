/*------------------------------------------------------------------------------------------ 
Copyright 2014, Celeste Gabriela Guagliano. 

This file is part of DXF2Machine project. 

DXF2Machine is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License. 

DXF2Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 

You should have received a copy of the GNU General Public License along with DXF2Machine. If not, see <http://www.gnu.org/licenses/>.
  --------------------------------------------------------------------------------------------*/


package cggGCode;

import java.util.Enumeration;
import java.util.Hashtable;

import javax.swing.JOptionPane;

import cggDatos.Coordenadas;
import cggDatos.DatosArcos;
import cggDatos.DatosCirculo;
import cggDatos.DatosLinea;
import cggDatos.EcuacionCircunferencia;
import cggDatos.EcuacionEntidad;
import cggDatos.EcuacionRecta;
import cggDatos.FormatoNumeros;
import cggDatos.Herramienta;
import cggDatos.datos;
import cggOptimizacion.OptimizacionMetodo2;
import d2mColeccion.ColeccionFunciones;

/**
 * This class implements the necessary algorithms to calculate a new contour compensating the radius of the selected tool to operate.  
 * @author: Celeste G. Guagliano
 * @version: 13/01/15
 * 
 */ 
public class compensacionContorno {
	
	/** Method to calculate the equation of the line 
	 * @param datosLinea it's the line generated by the equation wanted
	 * @param herramienta it's the tool involve in the process
	 * @return a line equation.
	 */
	public static EcuacionRecta calcularEcuacionRecta(datos datosLinea, double herramienta) {
		
		double A=0;
		double B=0;
		double C=0;
		double pendiente=0;
		double terminoIndependiente=0;
		Coordenadas iniciales=ColeccionFunciones.ObtenerCoordenadaInicioEntidad(datosLinea);
		Coordenadas finales=ColeccionFunciones.ObtenerCoordenadaFinEntidad(datosLinea);
		Coordenadas punto=new Coordenadas(0,0);
		
		double deltaX=(finales.x-iniciales.x);
		double deltaY=(finales.y-iniciales.y);
		if(deltaX!=0){
		B=1;
		pendiente=deltaY/deltaX;
		A=-pendiente;
		C=pendiente*iniciales.x-iniciales.y;
		}else{
		B=0;
		A=-1;
		C=iniciales.x;
		}
		EcuacionRecta original=new EcuacionRecta(A,B,C);
		punto=datosLinea.ObtenerPuntoSobreRectaCompensada(herramienta,original);
		EcuacionRecta compensada=new EcuacionRecta(0,0,0);
		compensada=calcularRectaParalela(original,punto);
		return compensada;
	}

	/** Method to calculate the equation of parallel line to another given line. 
	 * @param original is the given line.
	 * @param punto is a point include in the parallel line.
	 * @return a line equation.
	 */
		private static EcuacionRecta calcularRectaParalela(EcuacionRecta original,
		Coordenadas punto) {
	    EcuacionRecta compensada= new EcuacionRecta(original.A,original.B,0);
	    compensada.C=-compensada.A*punto.x-original.B*punto.y;
	 	return compensada;
}

		
		/** Method to calculate the equation a circumference
		 * @param datosCirculo is an entity.
		 * @param radioHerramienta is the tool radius.
		 * @return a circumference equation.
		 */
		public static EcuacionCircunferencia calcularEcuacionCircunferencia(datos datosCirculo, double radioHerramienta) {
			EcuacionCircunferencia ecuacion=new EcuacionCircunferencia(0,0,0);
			if(datosCirculo instanceof DatosCirculo){
				DatosCirculo dato=(DatosCirculo)datosCirculo;
				ecuacion.centroX=dato.CentroX;
				ecuacion.centroY=dato.CentroY;
				ecuacion.Radio=dato.Radio+radioHerramienta;
			}else{
				DatosArcos datos=(DatosArcos)datosCirculo;
				ecuacion.centroX=datos.Xcentro;
				ecuacion.centroY=datos.Ycentro;
				if(datos.orientacion==0){
					ecuacion.Radio=datos.radio-radioHerramienta;
				}else{
					ecuacion.Radio=datos.radio+radioHerramienta;
				}
			}
		return ecuacion;
	}

		/** Method to calculate an intersection point between two equations.
		 * @param listaOptimizada a list of entities.
		 * @param listaEcuaciones a list of equations.
		 * @return a list.
		 */
	public static Hashtable intersectarEcuacionesCompensadas(
			Hashtable listaOptimizada, Hashtable listaEcuaciones) {
		Hashtable listaCompensada=new Hashtable();
		int j=0;
		for(int i=1;i<=listaEcuaciones.size();i++){
			EcuacionEntidad ecuacion1=(EcuacionEntidad)listaEcuaciones.get(i);
			EcuacionEntidad ecuacion2=null;
			datos elemento1=(datos)listaOptimizada.get(i);
			datos elemento2=null;
			if(i<listaEcuaciones.size()){
				j=i+1;
				ecuacion2=(EcuacionEntidad)listaEcuaciones.get(j);
				elemento2=(datos)listaOptimizada.get(j);
			}else{
				j=1;
				ecuacion2=(EcuacionEntidad)listaEcuaciones.get(j);
				elemento2=(datos)listaOptimizada.get(j);
			}
			if(elemento1!=elemento2){
			listaCompensada=OptimizacionMetodo2.intersectarEntidades(i,j,ecuacion1,elemento1,ecuacion2,elemento2,listaCompensada);
			}else{
				listaCompensada=compensarCircunferencia(i,(EcuacionCircunferencia)ecuacion1,(DatosCirculo)elemento1);
			}
		}
	
		return listaCompensada;
	}


	/** Method to gets a compensated circumference.
	 * @param key is the position in the hashtable.
	 * @param ecuacion1 is the circumference equation.
	 * @param elemento1 is the circumference to compensate.
	 * @return a list.
	 */
	private static Hashtable compensarCircunferencia(int key,
			EcuacionCircunferencia ecuacion1, DatosCirculo elemento1) {
		Hashtable listaCompensada=new Hashtable();
		elemento1.ComienzoX=(double) FormatoNumeros.formatearNumero(elemento1.CentroX-ecuacion1.Radio);
		elemento1.FinalX=(double) FormatoNumeros.formatearNumero(elemento1.CentroX+ecuacion1.Radio);
		elemento1.Radio=(double) FormatoNumeros.formatearNumero(ecuacion1.Radio);
		listaCompensada.put(key, elemento1);
		return listaCompensada;
	}


	/** Method to calculate the intersection point between two lines.
	 * @param ecuacion1 is the first line equation.
	 * @param ecuacion2 is the second line equation.
	 * @return a point.
	 */
	public static Coordenadas intersectarRectas(EcuacionRecta ecuacion1,
			EcuacionRecta ecuacion2) {
		Coordenadas interseccion=new Coordenadas(0,0);
		if(ecuacion1.B!=0){
			if(ecuacion2.B!=0){
				interseccion.x=(ecuacion1.C/ecuacion1.B-ecuacion2.C/ecuacion2.B)/(ecuacion2.A/ecuacion2.B-ecuacion1.A/ecuacion1.B);
				interseccion.y=-ecuacion1.A/ecuacion1.B*interseccion.x-ecuacion1.C/ecuacion1.B;
			}else{
				interseccion.x=-ecuacion2.C/ecuacion2.A;
				interseccion.y=-ecuacion1.A/ecuacion1.B*interseccion.x-ecuacion1.C/ecuacion1.B;
			}
		}else{
			interseccion.x=-ecuacion1.C/ecuacion1.A;
			interseccion.y=-ecuacion2.A/ecuacion2.B*interseccion.x-ecuacion2.C/ecuacion2.B;			
		}
		interseccion.x=(double) FormatoNumeros.formatearNumero(interseccion.x);
		interseccion.y=(double) FormatoNumeros.formatearNumero(interseccion.y);
		return interseccion;
	}


	/** Method to calculate the point of intersection between a line and a circumference.
	 * @param ecuacion1 is the line's equation.
	 * @param ecuacion2 is the circumference's equation.
	 * @param elemento2 is the Arc's data.
	 * @return a point.
	 */
	public static Coordenadas intersectarArcoYRecta(EcuacionRecta ecuacion1,
			EcuacionCircunferencia ecuacion2, DatosArcos elemento2) {
		Coordenadas interseccion=new Coordenadas(0,0);
		Coordenadas finArco=ColeccionFunciones.ObtenerCoordenadaFinEntidad(elemento2);
		if(ecuacion1.A==0){
			interseccion=intersectarArcoConRectaHorizontal(ecuacion1,ecuacion2,finArco);
		}else if(ecuacion1.B==0){
			interseccion=intersectarArcoConRectaVertical(ecuacion1,ecuacion2,finArco);
		}else{
			interseccion=intersectarRectaConArcoCasoGeneral(ecuacion1,ecuacion2,finArco);
		}
		return interseccion;
	}

	/** Method to calculate the point of intersection between a line and a circumference.
	 * @param ecuacion1 is the line's equation.
	 * @param ecuacion2 is the circumference's equation.
	 * @param elemento2 is the Arc's data.
	 * @return a point.
	 */
	public static Coordenadas intersectarRectaYArco(EcuacionRecta ecuacion1,
	    EcuacionCircunferencia ecuacion2, DatosArcos elemento2) {
		Coordenadas interseccion=new Coordenadas(0,0);
		Coordenadas inicioArco=ColeccionFunciones.ObtenerCoordenadaInicioEntidad(elemento2);
		if(ecuacion1.A==0){
			interseccion=intersectarArcoConRectaHorizontal(ecuacion1,ecuacion2,inicioArco);
		}else if(ecuacion1.B==0){
			interseccion=intersectarArcoConRectaVertical(ecuacion1,ecuacion2,inicioArco);
		}else{
			interseccion=intersectarRectaConArcoCasoGeneral(ecuacion1,ecuacion2,inicioArco);
		}
		return interseccion;
		}
	
	/** Method to calculate the point of intersection between a line and a circumference.
	 * @param ecuacion1 is the line's equation.
	 * @param ecuacion2 is the circumference's equation.
	 * @param elemento2 is the Arc's data.
	 * @return a point.
	 */
		private static Coordenadas intersectarRectaConArcoCasoGeneral(
			EcuacionRecta ecuacion1, EcuacionCircunferencia ecuacion2,
			Coordenadas interseccionArcoOriginal) {
			JOptionPane.showMessageDialog(null, "Lo siento, la versiÃ³n actual no permite generar el contorneado seleccionado", "Error", JOptionPane.ERROR_MESSAGE);
			return null;
	}

		/** Method to calculate the point of intersection between a  vertical line and a circumference.
		 * @param ecuacion1 is the line's equation.
		 * @param ecuacion2 is the circumference's equation.
		 * @param elemento2 is the Arc's data.
		 * @return a point.
		 */
		private static Coordenadas intersectarArcoConRectaVertical(
			EcuacionRecta ecuacion1, EcuacionCircunferencia ecuacion2,
			Coordenadas interseccionArcoOriginal) {
		Coordenadas interseccion=new Coordenadas(0,0);
		interseccion.x=-ecuacion1.C/ecuacion1.A;
		System.out.println(ecuacion2.Radio+"*"+ecuacion2.Radio+"-Math.pow"+interseccion.x+"-"+ecuacion2.centroX);
		double parametroAlCuadrado=(ecuacion2.Radio*ecuacion2.Radio-Math.pow(interseccion.x-ecuacion2.centroX,2));
		double parametro=0;
		if(Math.abs(parametroAlCuadrado)>0.0001){
			parametro=Math.sqrt(parametroAlCuadrado);
		}
		double y1=ecuacion2.centroY+parametro;
		double y2=ecuacion2.centroY-parametro;
		interseccion.y=seleccionarPuntoY(ecuacion1,ecuacion2,y1,y2,interseccionArcoOriginal);
		interseccion.x=(double) FormatoNumeros.formatearNumero(interseccion.x);
		interseccion.y=(double) FormatoNumeros.formatearNumero(interseccion.y);
		return interseccion;
	}

		/** Method to select an intersection point of two possibilities.
		 * @param ecuacion2 is the circumference's equation
		 * @param y1 is the first possibly intersection point calculated.
		 * @param y2 is the second possibly intersection point calculated.
		 * @param interseccionArcoOriginal is the original point of intersection between an arc and another entity.
		 * @return a point.
		 */
		private static double seleccionarPuntoY(EcuacionRecta ecuacion1,
				EcuacionCircunferencia ecuacion2, double y1, double y2,
				Coordenadas interseccionArcoOriginal) {
			double y=0;
			double cumple1=ecuacion1.A*(-ecuacion1.B*y1/ecuacion1.A-ecuacion1.C/ecuacion1.A)+ecuacion1.B*y1+ecuacion1.C;
			double cumple2=ecuacion1.A*(-ecuacion1.B*y2/ecuacion1.A-ecuacion1.C/ecuacion1.A)+ecuacion1.B*y2+ecuacion1.C;
			if(cumple1==0){
				y=y1;
			}else{
				if(cumple2==0){
					y=y2;
				}
			}
			return y;
		}

		/** Method to calculate the point of intersection between an horizontal line and a circumference.
		 * @param ecuacion1 is the line's equation.
		 * @param ecuacion2 is the circumference's equation.
		 * @param elemento2 is the Arc's data.
		 * @return a point.
		 */
		private static Coordenadas intersectarArcoConRectaHorizontal(
			EcuacionRecta ecuacion1, EcuacionCircunferencia ecuacion2,
			Coordenadas interseccionArcoOriginal) {
		Coordenadas interseccion=new Coordenadas(0,0);
		interseccion.y=-ecuacion1.C/ecuacion1.B;
		double parametro=0;
		if(FormatoNumeros.formatearNumero(ecuacion2.Radio*ecuacion2.Radio)!=FormatoNumeros.formatearNumero(Math.pow(interseccion.y-ecuacion2.centroY,2))){
		parametro=Math.sqrt(ecuacion2.Radio*ecuacion2.Radio-Math.pow(interseccion.y-ecuacion2.centroY,2));
		}
		double x1=ecuacion2.centroX+parametro;
		double x2=ecuacion2.centroX-parametro;
		interseccion.x=seleccionarPuntoX(ecuacion2,x1,x2,interseccionArcoOriginal);
		interseccion.x=(double) FormatoNumeros.formatearNumero(interseccion.x);
		interseccion.y=(double) FormatoNumeros.formatearNumero(interseccion.y);
		return interseccion;
	}


		/** Method to select an intersection point of two possibilities.
		 * @param ecuacion2 is the circumference's equation
		 * @param x1 is the first possibly intersection point calculated.
		 * @param x2 is the second possibly intersection point calculated.
		 * @param interseccionArcoOriginal is the original point of intersection between an arc and another entity.
		 * @return a point.
		 */
		private static double seleccionarPuntoX(
				EcuacionCircunferencia ecuacion2, double x1, double x2,
				Coordenadas interseccionArcoOriginal) {
			double x=0;
			if(interseccionArcoOriginal.x<ecuacion2.centroX){
				if(x1<ecuacion2.centroX){
					x=x1;
				}else{
					x=x2;
				}
			}else{
				if(x1>ecuacion2.centroX){
					x=x1;
				}else{
					x=x2;
				}
			}
			return x;
		}

		/** Method to calculate the point of intersection between two circumferences.
		 * @param ecuacion1 is the first circumference's equation.
		 * @param ecuacion2 is the second circumference's equation.
		 * @param elemento1 is the first Arc's data.
		 * @param elemento1 is the second Arc's data. 
		 * @return a point.
		 */
	public static Coordenadas intersectarArcos(EcuacionCircunferencia ecuacion1,
			EcuacionCircunferencia ecuacion2, DatosArcos elemento1, DatosArcos elemento2) {
			JOptionPane.showMessageDialog(null, "Lo siento, la versiÃ³n actual no permite generar el contorneado seleccionado", "Error", JOptionPane.ERROR_MESSAGE);
			return null;
	}


	/** Method to calculate a list of equations from a list of entities.
	 * @param ecuacion2 is the circumference's equation
	 * @param y1 is the first possibly intersection point calculated.
	 * @param y2 is the second possibly intersection point calculated.
	 * @param interseccionArcoOriginal is the original point of intersection between an arc and another entity.
	 * @return a point.
	 */
	public static Hashtable ObtenerListaEcuaciones(
		Hashtable listaEntidadesCompensadas, double radioHerramienta) {
		Hashtable listaEcuaciones=new Hashtable();
		EcuacionEntidad ecuacion= new EcuacionEntidad();
		for(int i=1; i<listaEntidadesCompensadas.size()+1;i++){
			datos elemento=(datos)listaEntidadesCompensadas.get(i);
			ecuacion=elemento.calculaTuEcuacion(radioHerramienta);
			listaEcuaciones.put(i, ecuacion);
		}
		return listaEcuaciones;
	}

}



	

